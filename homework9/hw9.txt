1. Operational precedence:

	Operational precedence is order of evaluvation of operators. higher precedence operators are evaluvated first.

	Precedence level of operators:

20	   Grouping						n/a						( … )
19	   Member Access				left-to-right			… . …
	Computed Member Access			left-to-right			… [ … ]
	new (with argument list)		n/a					    new … ( … )
18	Function Call					left-to-right			… ( … )
new (without argument list)			right-to-left		    new …
17	Postfix Increment				n/a						… ++
Postfix Decrement					n/a						… --
16	Logical NOT						right-to-left			! …
Bitwise NOT							right-to-left			~ …
Unary Plus							right-to-left			+ …
Unary Negation						right-to-left			- …
Prefix Increment					right-to-left			++ …
Prefix Decrement					right-to-left			-- …
typeof								right-to-left			typeof …
void								right-to-left			void …
delete								right-to-left			delete …
15	Exponentiation					right-to-left			… ** …
14	Multiplication					left-to-right			… * …
Division							left-to-right			… / …
Remainder							left-to-right			… % …
13	Addition						left-to-right				… + …
Subtraction							left-to-right				… - …
12	Bitwise 						Left Shift	left-to-right	… << …
Bitwise 							Right Shift	left-to-right	… >> …
Bitwise Unsigned 					Right Shift	left-to-right	… >>> …
11	Less Than						left-to-right			… < …
Less Than Or Equal					left-to-right			… <= …
Greater Than						left-to-right			… > …
Greater Than Or Equal				left-to-right			… >= …
in									left-to-right			… in …
instanceof							left-to-right			… instanceof …
10	Equality						left-to-right			… == …
Inequality							left-to-right			… != …
Strict Equality						left-to-right			… === …
Strict Inequality					left-to-right			… !== …
9	Bitwise AND						left-to-right			… & …
8	Bitwise XOR						left-to-right			… ^ …
7	Bitwise OR						left-to-right			… | …
6	Logical AND						left-to-right			… && …
5	Logical OR						left-to-right			… || …
4	Conditional						right-to-left			… ? … : …
3	Assignment						right-to-left			… = …
															… += …
															… -= …
															… **= …
															… *= …
															… /= …
															… %= …
															… <<= …
															… >>= …
															… >>>= …
															… &= …
															… ^= …
															… |= …
2	yield							right-to-left			yield …
    yield*							right-to-left			yield* …
1	Spread							n/a						... …
0	Comma / Sequence				left-to-right			… , …



2. differences between == and ===
    
    	--== it mainly concentrates on values data type is taken into account.
    	--=== It concentrates on datatype and value too.

	JavaScript has both strict and type-converting equality comparison. For strict equality the objects being compared must have the same type and:

	Two strings are strictly equal when they have the same sequence of characters, same length, and same characters in corresponding positions.
	Two numbers are strictly equal when they are numerically equal (have the same number value). NaN is not equal to anything, including NaN. Positive and negative zeros are equal to one another.
	Two Boolean operands are strictly equal if both are true or both are false.
	Two objects are strictly equal if they refer to the same Object.
	Null and Undefined types are == (but not ===). [I.e. (Null==Undefined) is true but (Null===Undefined) is false]

 diff between != & !==
	
	!= is not equal.
	--!= it mainly concentrates on values data type is taken into account.
	!== not equal or not equal type.
	--!== It concentrates on datatype and value too.

3. difference between undefined and null

	-undefined is something that is declared and not assigned anything.
	-null is assignment value used to assign a variable which has novalue.
	-if we are trying to refer a null value gives an error.

